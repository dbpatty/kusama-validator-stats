"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeLatestSubstrate = decodeLatestSubstrate;
exports.toLatest = toLatest;
exports.defaultValues = defaultValues;

var _create = require("@polkadot/types/codec/create");

var _StorageKey = require("@polkadot/types/primitive/StorageKey");

var _getUniqTypes = _interopRequireDefault(require("./getUniqTypes"));

var _Metadata = _interopRequireDefault(require("../Metadata"));

// Copyright 2017-2019 @polkadot/metadata authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.

/**
 * Given the static `rpcData` and the `staticSubstrate` JSON file, Metadata
 * should decode `rpcData` and output `staticSubstrate`.
 */
function decodeLatestSubstrate(registry, version, rpcData, staticSubstrate) {
  it('decodes latest substrate properly', () => {
    const metadata = new _Metadata.default(registry, rpcData);

    try {
      expect(metadata.version).toBe(version);
      expect(metadata["asV".concat(version)].modules.length).not.toBe(0);
      expect(metadata.toJSON()).toEqual(staticSubstrate);
    } catch (error) {
      console.error(JSON.stringify(metadata.toJSON()));
      throw error;
    }
  });
}
/**
 * Given a `version`, MetadataLatest and MetadataV{version} should output the same
 * unique types.
 */


function toLatest(registry, version, rpcData) {
  it("converts v".concat(version, " to v8"), () => {
    const metadata = new _Metadata.default(registry, rpcData)["asV".concat(version)];
    const metadataLatest = new _Metadata.default(registry, rpcData).asLatest;
    expect((0, _getUniqTypes.default)(registry, metadata, true)).toEqual((0, _getUniqTypes.default)(registry, metadataLatest, true));
  });
}
/**
 * Given a Metadata, no type should throw when given its fallback value.
 */


function defaultValues(registry, rpcData) {
  describe('storage with default values', () => {
    const metadata = new _Metadata.default(registry, rpcData);
    metadata.asLatest.modules.filter((_ref) => {
      let {
        storage
      } = _ref;
      return storage.isSome;
    }).forEach(mod => {
      mod.storage.unwrap().items.forEach((_ref2) => {
        let {
          fallback,
          name,
          type
        } = _ref2;
        const inner = (0, _StorageKey.unwrapStorageType)(type);
        const location = "".concat(mod.name, ".").concat(name, ": type ").concat(inner);
        it("creates default types for ".concat(location), () => {
          expect(() => {
            try {
              return (0, _create.createTypeUnsafe)(registry, inner, [fallback]);
            } catch (error) {
              throw new Error("".concat(location, ":: ").concat(error.message));
            }
          }).not.toThrow();
        });
      });
    });
  });
}