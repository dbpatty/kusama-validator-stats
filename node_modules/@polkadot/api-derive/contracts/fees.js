"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fees = fees;

var _bn = _interopRequireDefault(require("bn.js"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _util = require("../util");

// Copyright 2017-2019 @polkadot/api-derive authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const ZERO = new _bn.default(0); // parse the result

function parseResult(_ref) {
  let [callBaseFee, contractFee, createBaseFee, creationFee, rentByteFee, rentDepositOffset, tombstoneDeposit, transactionBaseFee, transactionByteFee, transferFee] = _ref;
  return {
    callBaseFee,
    contractFee,
    createBaseFee,
    creationFee,
    rentByteFee,
    rentDepositOffset,
    tombstoneDeposit,
    transactionBaseFee,
    transactionByteFee,
    transferFee
  };
} // query via constants (current applicable path)


function queryConstants(api) {
  return (0, _rxjs.of)([api.consts.contracts.callBaseFee, api.consts.contracts.contractFee, api.consts.contracts.createBaseFee, api.consts.contracts.creationFee, api.consts.contracts.rentByteFee, api.consts.contracts.rentDepositOffset, api.consts.contracts.tombstoneDeposit, api.consts.contracts.transactionBaseFee, api.consts.contracts.transactionByteFee, api.consts.contracts.transferFee]);
}
/**
 * @name fees
 * @returns An object containing the combined results of the queries for
 * all relevant contract fees as declared in the substrate chain spec.
 * @example
 * <BR>
 *
 * ```javascript
 * api.derive.contracts.fees(([creationFee, transferFee]) => {
 *   console.log(`The fee for creating a new contract on this chain is ${creationFee} units. The fee required to call this contract is ${transferFee} units.`);
 * });
 * ```
 */


function fees(api) {
  return (0, _util.memo)(() => {
    return (api.consts.contracts ? queryConstants(api) : (0, _rxjs.of)([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO])).pipe((0, _operators.map)((_ref2) => {
      let [callBaseFee, contractFee, createBaseFee, creationFee, rentByteFee, rentDepositOffset, tombstoneDeposit, transactionBaseFee, transactionByteFee, transferFee] = _ref2;
      return (// We've done this on purpose, i.e. so we can  just copy the name/order from the parse above and see gaps
        parseResult([callBaseFee, contractFee, createBaseFee, creationFee, rentByteFee, rentDepositOffset, tombstoneDeposit, transactionBaseFee, transactionByteFee, transferFee])
      );
    }));
  });
}